---
title: 'Operating System: Xv6 on RISC-V - Part 2'
date: 2024-05-03
permalink: /posts/os-part2/
tags:
  - Operation System
  - Xv6
  - RISC-V

---

## Operating System: Xv6 on RISC-V - Paging & Page Table

## Paging
* Physical memory partitioned into equal-sized page frames. The typical size of a page frame is 4KB. Other possible page sizes: 512B, 64KB, 1MB, 4MB, etc
* Memory only allocatied in page frames. No external fragmentation. Can still have internal fragmentation(no enought space left within a page frame).

### Physical Address
* A physical address can be split into a pait (f, o)
    * f: frame number (f_max frames)
    * o: offset within the frame (O_max bytes/frame)
* Physical address = f * O_max + o
* As long as frame size is power of 2, easy to split address using bitwise operations

#### Physical Address Example
Suppose a 16-bit address space with 512(2^9) byte page frames.  
Address 1542(0x0606) can be translated to:
* Frame: 1542 / 512 = 0x606 >> 9 = 3
* Offset: 1542 % 512 = 0x606 & 0x1ff = 6
![Physical Address Example](/images/os/os_pae.png)

### Virtual Address
* A process’s virtual address space is partitioned into equal-sized pages. A virtual address is a pair (p, o)   
**Virtual page size = Physical frame size**
    * p: page number (p_max pages)
    * o: offset within the page (O_max bytes/page)
* Virtual address = p * O_max + o
![Virtual Address](/images/os/os_va.png)

### Page Mapping
* 1:1 mapping of page-aligned virtual addresses to physical frames
* Imagine a big ole’ table (BOT):
    * Number of table entries = number of virtual page addresses/page size
* Address translation:
    * Virtual page number -> BOT entry -> Physical frame number
    * Add offset to physical frame number to get physical address
* Pages are contiguous in virtual address space, but not necessarily in physical address space
* Not all pages are mapped to physical memory at all times
    * Some pages may be swapped out to disk
    * Some pages may be shared between processes

## Page Table
![Page Table](/images/os/os_ptd.png){:width=50%}

![Page Table Example](/images/os/os_pte.png){:width=50%}

### Dealing with Large Tables
* Add additional levels of page table
* Sub-dividing page number into k parts
![Multi-level Page Table](/images/os/os_lt.png)

A single-level, 1-1 page table takes enormous space.  
* Linked list – too slow to walk
* Hashed table – collision
* Multi-level page table

### 32-bit x86 Page Table
![32-bit x86 Page Table](/images/os/os_32pt.png)
* Each table is exactly one page. 4KB(4096) for x86
* Two-level of page table
    * Page Directory: 1024 entries
    * Page Table: 1024 entries
* CR3 (a control register): stores the physical base (PA >> 12) of the page directory table

### Page Table Entries(PTEs)
![Page Table Entries](/images/os/os_pte86.png)
* Fixed bits for the PFN (Page frame number) of the next PTs or pages.
    * Physical address = PFN * page size
* The remaining bits are used for flags, or reserved for OS use
    * P (Present): Is the page present or not?
    * R/W (Read/Write): Is the page read-only or readable/writable?
    * U/S (User or Supervisor): User or kernel page?
    * A (Accessed): page has been read
    * D (Dirty): page has been written
    * G (Global): page is shared among processes


