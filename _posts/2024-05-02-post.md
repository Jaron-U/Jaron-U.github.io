---
title: 'Operating System: Xv6 on RISC-V'
date: 2024-05-03
permalink: /posts/2024/05/blog-post-4/
tags:
  - Operation System
  - Xv6
  - RISC-V

---

Run Xv6(like Unix) using RISC-V(Architecture) on QEMU(Emulator).

```bash
# install required packages
sudo apt-get install flex bison git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu opensbi expect
```

#### Build and run xv6
```bash
make qemu
```

#### Debug xv6
First, can create a .gdbinit file in the home directory.

```bash
echo "set auto-load safe-path /" > ~/.gdbinit
```

Then, run the following command to start gdb.

```bash
# run this in one terminal
make qemu-gdb

# run this in another terminal
make run-gdb

# show the source code in a terminal
layout src

# show the backtrace
bt # backtrace

# set breakpoint in the user space
symbol-file user/ls.o
b user/ls.c:10
```

## System Call in XV6
System Call are the APIs for the user space to interact with the kernel space, access resources and hardware without knowing low-level details.

### About System Call
* Allow processes to interact with the kernel by transitioning from user mode
to kernel mode.
* Allow protected access from applications to memory, I/O devices and other
protected subsystems
* Perform read/write files, create processes, allocate memory etc.
* Invoked by API functions in glibc like printf(), exit(), open() etc which trigger
a context switch to kernel mode.
* When the OS service completes, it returns to user mode where the process
resumes.
* Each system call has a unique number that identifies to the kernel which
service is being requested.

### Trap into the kernel
1. System classs(Planned): User -> Kernel
    * SYSCALL for I/O, memory allocation, process creation etc.
2. Exception(error): User -> Kernel
    * Page fault, divide by zero, invalid instruction etc.
3. Interrupt(event): Device -> Kernel
    * Keyboard event, network packet, timer ticks, hardward events, etc.

### System Call Implementation
1. Add an entry for the new system call to the syscall array in the `syscall.c` file.
2. write the implementation of the system call in the `sysproc.c` file.
3. add function prototype in the `syscall.c` file. e.g., `extern int sys_hello(void);`
4. define the system call in the `syscall.h` file. e.g., `#define SYS_hello 22`
5. create an interface in the `usys.pl` file. e.g., `entry(hello)`, allow the user to call the system call.
6. add the system call to the `user.h` file. e.g., `int hello(void);`

### RISC-V Calling Convention
RISC-V uses ecall to invoke system calls
* a0-a6: syscall arguments(up to 7)
* a7: syscall number
* a0(after ecall): return value

## Address Translation
Computer runs multiple processes at the same time, each process has its own memory and CPU state (address space). Cannot see the state of each other.
![img](/images/os_as.png){:width="80%"}

### Physical Address
The main memory of a computer is organized as a array of M contiguous byte-size cells.
When the CPU wants to access a memory location, it sends the address to the memory controller(bus), which reads the data from the memory location and sends it back to the CPU, and stores it in a register.

### Virtual Address
![img](/images/os_va.png){:width="80%"}

* The CPU accesses main memory by generating a virtual address, which is converted to the appropriate physical address before being sent to main memory.
* Address translation converts a virtual address to a physical address.
* Like exception handling, address translation requires cooperation between the CPU and the OS.
* Dedicated hardware on the CPU chip (MMU) translates virtual addresses on the fly, using a lookup table stored in main memory whose contents are managed by the operating system.

### Physical VS Virtual Address
* Physical Address Space: address space supported by the hardware; Starts at address 0, and ends and the address MAXsys  
* Virtual Address Space: address space view of a process; Starts at address 0, going to address MAXprog

### Address Spaces
* An address space is an ordered set of nonnegative integer addresses {0,1,2,...}
* In a system with virtual memory, the CPU generates virtual addresses from an address space of N = $$2^n$$ addresses called the virtual address space: {0,1,2,...,Nâˆ’1}
* The size of an address space is characterized by the number of bits that are needed to represent the largest address.
* e.g., a virtual address space with N = $$2^n$$ addresses is called an n-bit address space.
* Modern systems typically support either 32-bit or 64-bit virtual address spaces.

### Simple Memory Management
* Allocate a partition when a process is admitted into the system
* Allocate a contiguous memory partition to the process  
The OS Keeps track of of:  
Full-blocks  
Empty-blocks("holes")


